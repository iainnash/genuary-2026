#!/usr/bin/env ruby
require_relative '../drawing_interface'

# Merlin G-code implementation of the drawing interface
class GcodeDrawing < DrawingInterface
  def initialize(options = {})
    super
    @options = {
      feed_rate: 1000,       # Feed rate for movement in mm/min
      pen_up_position: 90,   # Servo angle for pen up
      pen_down_position: 30, # Servo angle for pen down
      pen_delay: 300,        # Delay after pen movement in ms
      bed_width: 300,        # Bed width in mm
      bed_height: 200,       # Bed height in mm
      origin_x: 10,          # X offset from origin in mm
      origin_y: 10           # Y offset from origin in mm
    }.merge(@options)
    
    @commands = []
    @commands << "; Merlin G-code generated by GlyphDSL"
    @commands << "G21 ; Set units to millimeters"
    @commands << "G90 ; Set to absolute positioning"
    @commands << "M280 P0 S#{@options[:pen_up_position]} ; Pen up"
    @commands << "G0 X#{@options[:origin_x]} Y#{@options[:origin_y]} ; Move to origin"
    @commands << "G4 P#{@options[:pen_delay]} ; Wait for pen to move"
    
    # Current position tracking
    @current_x = @options[:origin_x]
    @current_y = @options[:origin_y]
    @pen_down = false
    @current_letter = nil
  end

  def move_to(x, y)
    # Scale to fit within bed size
    x_scaled = @options[:origin_x] + x
    y_scaled = @options[:origin_y] + y
    
    # Ensure within bed limits
    x_scaled = [[@options[:origin_x], x_scaled].max, @options[:bed_width]].min
    y_scaled = [[@options[:origin_y], y_scaled].max, @options[:bed_height]].min
    
    # G0 for rapid movement with pen up, G1 for controlled movement with pen down
    command = @pen_down ? "G1" : "G0"
    feed_rate = @pen_down ? " F#{@options[:feed_rate]}" : ""
    
    @commands << "#{command} X#{x_scaled.round(3)} Y#{y_scaled.round(3)}#{feed_rate}"
    
    @current_x = x_scaled
    @current_y = y_scaled
  end

  def pen_down
    unless @pen_down
      @commands << "M280 P0 S#{@options[:pen_down_position]} ; Pen down"
      @commands << "G4 P#{@options[:pen_delay]} ; Wait for pen to move"
      @pen_down = true
    end
  end

  def pen_up
    if @pen_down
      @commands << "M280 P0 S#{@options[:pen_up_position]} ; Pen up"
      @commands << "G4 P#{@options[:pen_delay]} ; Wait for pen to move"
      @pen_down = false
    end
  end

  def line(x1, y1, x2, y2)
    pen_up
    move_to(x1, y1)
    pen_down
    move_to(x2, y2)
    pen_up
  end

  def arc(x, y, radius, start_angle, end_angle)
    # Convert angles from degrees to radians
    start_rad = start_angle * Math::PI / 180
    end_rad = end_angle * Math::PI / 180
    
    # Calculate start point
    start_x = x + radius * Math.cos(start_rad)
    start_y = y + radius * Math.sin(start_rad)
    
    # Calculate end point
    end_x = x + radius * Math.cos(end_rad)
    end_y = y + radius * Math.sin(end_rad)
    
    # Move to start position
    pen_up
    move_to(start_x, start_y)
    pen_down
    
    # Determine if the arc is more than 180 degrees
    # If so, we need to split it into multiple arcs (G2/G3 can only do up to 180 degrees)
    if (end_angle - start_angle).abs > 180
      # Split into two arcs
      mid_angle = start_angle + (end_angle - start_angle) / 2
      mid_rad = mid_angle * Math::PI / 180
      mid_x = x + radius * Math.cos(mid_rad)
      mid_y = y + radius * Math.sin(mid_rad)
      
      # Draw first half of the arc
      draw_arc_segment(start_x, start_y, mid_x, mid_y, x, y, start_angle < end_angle)
      
      # Draw second half of the arc
      draw_arc_segment(mid_x, mid_y, end_x, end_y, x, y, start_angle < end_angle)
    else
      # Draw the arc in one command
      draw_arc_segment(start_x, start_y, end_x, end_y, x, y, start_angle < end_angle)
    end
    
    pen_up
  end

  def circle(x, y, radius)
    # For a complete circle, we need to split it into two 180-degree arcs
    # First half
    arc(x, y, radius, 0, 180)
    # Second half
    arc(x, y, radius, 180, 360)
  end

  def render
    # Add final commands
    @commands << "M280 P0 S#{@options[:pen_up_position]} ; Final pen up"
    @commands << "G0 X#{@options[:origin_x]} Y#{@options[:origin_y]} ; Return to origin"
    @commands << "M84 ; Disable motors"
    @commands.join("\n")
  end
  
  # Override draw_glyph to add letter comments
  def draw_glyph(glyph_data, x, y, scale = 1.0, letter = nil)
    # Add a comment for the letter if provided
    if letter && letter != @current_letter
      @commands << "\n; Letter: #{letter}"
      @current_letter = letter
    end
    
    # Call the parent method to draw the glyph
    super(glyph_data, x, y, scale)
  end
  
  private
  
  def draw_arc_segment(start_x, start_y, end_x, end_y, center_x, center_y, is_ccw)
    # Scale coordinates
    start_x_scaled = @options[:origin_x] + start_x
    start_y_scaled = @options[:origin_y] + start_y
    end_x_scaled = @options[:origin_x] + end_x
    end_y_scaled = @options[:origin_y] + end_y
    center_x_scaled = @options[:origin_x] + center_x
    center_y_scaled = @options[:origin_y] + center_y
    
    # Calculate I and J offsets (from current position to arc center)
    i_offset = center_x_scaled - start_x_scaled
    j_offset = center_y_scaled - start_y_scaled
    
    # Ensure we're at the start position
    if @current_x != start_x_scaled || @current_y != start_y_scaled
      move_to(start_x, start_y)
    end
    
    # Make sure pen is down
    pen_down
    
    # Use G2 for clockwise, G3 for counter-clockwise
    command = is_ccw ? "G3" : "G2"
    
    # Generate the arc command with I and J offsets
    @commands << "#{command} X#{end_x_scaled.round(3)} Y#{end_y_scaled.round(3)} I#{i_offset.round(3)} J#{j_offset.round(3)} F#{@options[:feed_rate]}"
    
    # Update current position
    @current_x = end_x_scaled
    @current_y = end_y_scaled
  end
end